$VERSION = 0.7;

# pp_setversion $VERSION;  # haven't worked out why it breaks my system (CS)
pp_beginwrap; # required for overload to work

# pp_def functions go into the PDL::Complex namespace
# to avoid clashing with PDL::FFTW funcs of the same name that go
# into the PDL namespace
# it should be of no effect to the user of the module but you
# never know....
pp_bless('PDL::Complex');

pp_addpm {At => Top}, <<'EOD';
   use PDL::Slices;
   use PDL::Types;
   use PDL::Bad;

   use vars qw($sep $sep2);
EOD

pp_addpm { At => Top}, `cat complex3.pod`;

pp_addpm {At => Top}, <<'EOD';
my $i;
BEGIN { $i = bless pdl 0,1 }
sub i () { $i->copy };
EOD

for (qw(Ctan Catan re im i cplx real)) {
   pp_add_exported '', $_;
}

pp_addhdr `cat complex3.include.c`;

pp_addpm `cat complex3.include.pm`;

pp_def 'r2C',
       Pars => 'r(); [o]c(m=2)',
       Doc => 'convert real to complex, assuming an imaginary part of zero',
       PMCode => << 'EOPM',

*PDL::r2C = \&PDL::Complex::r2C;
sub PDL::Complex::r2C($) {
  return $_[0] if UNIVERSAL::isa($_[0],'PDL::Complex');
  my $r = __PACKAGE__->initialize;
  &PDL::Complex::_r2C_int($_[0], $r);
  $r }

EOPM
       Code => q!
          $c(m=>0) = $r();
          $c(m=>1) = 0;
       !
;

pp_def 'i2C',
       Pars => 'r(); [o]c(m=2)',
       Doc => 'convert imaginary to complex, assuming a real part of zero',
       PMCode => '*PDL::i2C = \&PDL::Complex::i2C; sub PDL::Complex::i2C($) { my $r = __PACKAGE__->initialize; &PDL::Complex::_i2C_int($_[0], $r); $r }',
       Code => q!
          $c(m=>0) = 0;
          $c(m=>1) = $r();
       !
;

pp_def 'Cr2p',
       Pars => 'r(m=2); float+ [o]p(m=2)',
       Inplace => 1,
       Doc => 'convert complex numbers in rectangular form to polar (mod,arg) form. Works inplace',
       Code => q!
          $GENERIC() x = $r(m=>0);
          $GENERIC() y = $r(m=>1);
          $p(m=>0) = CABS (x, y);
          $p(m=>1) = atan2 (y, x);
       !
;

pp_def 'Cp2r',
       Pars => 'r(m=2); [o]p(m=2)',
       Inplace => 1,
       GenericTypes => [F,D],
       Doc => 'convert complex numbers in polar (mod,arg) form to rectangular form. Works inplace',
       Code => q!
          $GENERIC() m = $r(m=>0);
          $GENERIC() a = $r(m=>1);
          double s, c;

          SINCOS (a, s, c);
          $p(m=>0) = c * m;
          $p(m=>1) = s * m;
       !
;

pp_def 'Cadd', # this is here for a) completeness and b) not having to mess with PDL::Ops
	Pars => 'a(m=2); b(m=2); [o]c(m=2)',
        Doc => undef,
        Code => q^
           $GENERIC() ar = $a(m=>0), ai = $a(m=>1);
           $GENERIC() br = $b(m=>0), bi = $b(m=>1);
           $c(m=>0) = ar + br;
           $c(m=>1) = ai + bi;
        ^
;

pp_def 'Csub', # this is here for a) completeness and b) not having to mess with PDL::Ops
	Pars => 'a(m=2); b(m=2); [o]c(m=2)',
        Doc => undef,
        Code => q^
           $GENERIC() ar = $a(m=>0), ai = $a(m=>1);
           $GENERIC() br = $b(m=>0), bi = $b(m=>1);
           $c(m=>0) = ar - br;
           $c(m=>1) = ai - bi;
        ^
;

pp_def 'Cmul',
	Pars => 'a(m=2); b(m=2); [o]c(m=2)',
        Doc => 'complex multiplication',
        Code => q^
           $GENERIC() ar = $a(m=>0), ai = $a(m=>1);
           $GENERIC() br = $b(m=>0), bi = $b(m=>1);
           $c(m=>0) = ar*br - ai*bi;
           $c(m=>1) = ar*bi + ai*br;
        ^
;

pp_def 'Cprodover',
	Pars => 'a(m=2,n); [o]c(m=2)',
        Doc => 'Project via product to N-1 dimension',
        Code => q^
	    PDL_Long iter;
	    $GENERIC() br, bi, cr, ci,tmp;
	    cr = $a(m=>0,n=>0);
	    ci = $a(m=>1,n=>0);
	   for  (iter=1; iter < $SIZE(n);iter++)
	   {
		   br = $a(m=>0,n=>iter);
		   bi = $a(m=>1,n=>iter);
		   tmp =  cr*bi + ci*br;
	           cr = cr*br - ci*bi;
	           ci = tmp;
           }
	    $c(m=>0) = cr;
	    $c(m=>1) = ci;
        ^
;

pp_def 'Cscale',
	Pars => 'a(m=2); b(); [o]c(m=2)',
        Doc => 'mixed complex/real multiplication',
        Code => q^
           $GENERIC() ar = $a(m=>0), ai = $a(m=>1);
           $c(m=>0) = ar * $b();
           $c(m=>1) = ai * $b();
        ^
;

pp_def 'Cdiv',
	Pars => 'a(m=2); b(m=2); [o]c(m=2)',
        GenericTypes => [F,D],
        Doc => 'complex division',
        Code => q^
           $GENERIC() ar = $a(m=>0), ai = $a(m=>1);
           $GENERIC() br = $b(m=>0), bi = $b(m=>1);

           if (fabs (br) > fabs (bi))
             {
               $GENERIC() tt = bi / br;
               $GENERIC() dn = br + tt * bi;
               $c(m=>0) = (ar + tt * ai) / dn;
               $c(m=>1) = (ai - tt * ar) / dn;
             }
           else
             {
               $GENERIC() tt = br / bi;
               $GENERIC() dn = br * tt + bi;
               $c(m=>0) = (ar * tt + ai) / dn;
               $c(m=>1) = (ai * tt - ar) / dn;
             }
        ^
;

pp_def 'Ccmp',
	Pars => 'a(m=2); b(m=2); [o]c()',
        GenericTypes => [F,D],
        Doc => 'Complex comparison oeprator (spaceship). It orders by real first, then by imaginary. Hm, but it is mathematical nonsense! Complex numbers cannot be ordered.',
        Code => q^
           $GENERIC() a, b;

           a = $a(m=>0), b = $b(m=>0);
           if (a != b)
             $c() = (a > b) * 2 - 1;
           else
             {
               a = $a(m=>1), b = $b(m=>1);
               $c() = a == b ? 0
                             : (a > b) * 2 - 1;
             }
        ^
;

pp_def 'Cconj',
	Pars => 'a(m=2); [o]c(m=2)',
	Inplace => 1,
        Doc => 'complex conjugation. Works inplace',
        Code => q^
           $c(m=>0) =  $a(m=>0);
           $c(m=>1) = -$a(m=>1);
        ^
;

pp_def 'Cabs',
	Pars => 'a(m=2); [o]c()',
        GenericTypes => [F,D],
        Doc => 'complex C<abs()> (also known as I<modulus>)',
        PMCode => q^sub PDL::Complex::Cabs($) {
           my $pdl= shift;
           my $abs = PDL->null;
           &PDL::Complex::_Cabs_int($pdl, $abs);
           $abs;
        }^,
        Code => q^
           $GENERIC() ar = $a(m=>0), ai = $a(m=>1);
           $c() = CABS (ar, ai);
        ^
;

pp_def 'Cabs2',
	Pars => 'a(m=2); [o]c()',
        Doc => 'complex squared C<abs()> (also known I<squared modulus>)',
        PMCode => q^sub PDL::Complex::Cabs2($) {
           my $pdl= shift;
           my $abs2 = PDL->null;
           &PDL::Complex::_Cabs2_int($pdl, $abs2);
           $abs2;
        }^,
        Code => q^
           $GENERIC() ar = $a(m=>0), ai = $a(m=>1);
           $c() = ar*ar + ai*ai;
        ^
;

pp_def 'Carg',
	Pars => 'a(m=2); [o]c()',
        GenericTypes => [F,D],
        Doc => 'complex argument function ("angle")',
        PMCode => q^sub PDL::Complex::Carg($) {
           my $pdl= shift;
           my $arg = PDL->null;
           &PDL::Complex::_Carg_int($pdl, $arg);
           $arg;
        }^,
        Code => q^
           $c() = atan2 ($a(m=>1), $a(m=>0));
        ^
;

pp_def 'Csin',
	Pars => 'a(m=2); [o]c(m=2)',
	Inplace => 1,
        GenericTypes => [F,D],
        Doc => '  sin (a) = 1/(2*i) * (exp (a*i) - exp (-a*i)). Works inplace',
        Code => q^
           $GENERIC() ar = $a(m=>0), ai = $a(m=>1);
           double s, c;

           SINCOS (ar, s, c);
           $c(m=>0) = s * cosh (ai);
           $c(m=>1) = c * sinh (ai);
        ^
;

pp_def 'Ccos',
	Pars => 'a(m=2); [o]c(m=2)',
	Inplace => 1,
        GenericTypes => [F,D],
        Doc => '  cos (a) = 1/2 * (exp (a*i) + exp (-a*i)). Works inplace',
        Code => q^
           $GENERIC() ar = $a(m=>0), ai = $a(m=>1);
           double s, c;

           SINCOS (ar, s, c);
           $c(m=>0) =   c * cosh (ai);
           $c(m=>1) = - s * sinh (ai);
        ^
;

pp_def 'Cexp',
	Pars => 'a(m=2); [o]c(m=2)',
	Inplace => 1,
        GenericTypes => [F,D],
        Doc => 'exp (a) = exp (real (a)) * (cos (imag (a)) + i * sin (imag (a))). Works inplace',
        Code => q^
           $GENERIC() ar = $a(m=>0), ai = $a(m=>1);
           $GENERIC() ex = exp (ar);
           double s, c;

           SINCOS (ai, s, c);
           $c(m=>0) = ex * c;
           $c(m=>1) = ex * s;
        ^
;

pp_def 'Clog',
	Pars => 'a(m=2); [o]c(m=2)',
	Inplace => 1,
        GenericTypes => [F,D],
        Doc => 'log (a) = log (cabs (a)) + i * carg (a). Works inplace',
        Code => q^
           $GENERIC() ar = $a(m=>0), ai = $a(m=>1);

           CLOG (ar, ai, $c(m=>0), $c(m=>1));
        ^
;

pp_def 'Cpow',
	Pars => 'a(m=2); b(m=2); [o]c(m=2)',
	Inplace => ['a'],
        GenericTypes => [F,D],
        Doc => 'complex C<pow()> (C<**>-operator)',
        Code => q^
           $GENERIC() ar = $a(m=>0), ai = $a(m=>1);
           $GENERIC() br = $b(m=>0), bi = $b(m=>1);

           double logr, logi, x, y;
           double  s, c;

           if(ar == 0 && ai == 0){
             if(br == 0 && bi == 0) {
               $c(m=>0) = 1;
               $c(m=>1) = 0;
             }
             else {
               $c(m=>0) = 0;
               $c(m=>1) = 0;
             }
           }
           else {
             CLOG (ar, ai, logr, logi);
             x = exp (logr*br - logi*bi);
             y =      logr*bi + logi*br;

             SINCOS (y, s, c);

             $c(m=>0) = x * c;
             if(ai == 0 && bi == 0) $c(m=>1) = 0;
             else $c(m=>1) = x * s;
           }
        ^
;

pp_def 'Csqrt',
	Pars => 'a(m=2); [o]c(m=2)',
	Inplace => 1,
        GenericTypes => [F,D],
        Doc => 'Works inplace',
        Code => q^
           $GENERIC() ar = $a(m=>0), ai = $a(m=>1);

           CSQRT ($GENERIC(), ar, ai, $c(m=>0), $c(m=>1));
        ^
;

pp_def 'Casin',
	Pars => 'a(m=2); [o]c(m=2)',
	Inplace => 1,
        GenericTypes => [F,D],
        Doc => 'Works inplace',
        Code => q^
           $GENERIC() ar = $a(m=>0), ai = $a(m=>1);

           $GENERIC() t1 = sqrt ((ar+1)*(ar+1) + ai*ai);
           $GENERIC() t2 = sqrt ((ar-1)*(ar-1) + ai*ai);
           $GENERIC() alpha = (t1+t2)*0.5;
           $GENERIC() beta  = (t1-t2)*0.5;

           if      (alpha < 1) alpha = 1;
           if      (beta >  1) beta =  1;
           else if (beta < -1) beta = -1;

           $c(m=>0) =   atan2 (beta, sqrt (1-beta*beta));
           $c(m=>1) = - log (alpha + sqrt (alpha*alpha-1));
           if (ai > 0 || (ai == 0 && ar < -1))
              $c(m=>1) = - $c(m=>1);
        ^
;

pp_def 'Cacos',
	Pars => 'a(m=2); [o]c(m=2)',
	Inplace => 1,
        GenericTypes => [F,D],
        Doc => 'Works inplace',
        Code => q^
           $GENERIC() ar = $a(m=>0), ai = $a(m=>1);

           $GENERIC() t1 = sqrt ((ar+1)*(ar+1) + ai*ai);
           $GENERIC() t2 = sqrt ((ar-1)*(ar-1) + ai*ai);
           $GENERIC() alpha = (t1+t2)*0.5;
           $GENERIC() beta  = (t1-t2)*0.5;

           if      (alpha < 1) alpha = 1;
           if      (beta >  1) beta =  1;
           else if (beta < -1) beta = -1;

           $c(m=>0) = atan2 (sqrt (1-beta*beta), beta);
           $c(m=>1) = log (alpha + sqrt (alpha*alpha-1));
           if (ai > 0 || (ai == 0 && ar < -1))
              $c(m=>1) = - $c(m=>1);
        ^
;

pp_def 'Csinh',
	Pars => 'a(m=2); [o]c(m=2)',
	Inplace => 1,
        GenericTypes => [F,D],
        Doc => '  sinh (a) = (exp (a) - exp (-a)) / 2. Works inplace',
        Code => q^
           $GENERIC() ar = $a(m=>0), ai = $a(m=>1);
           double s, c;

           SINCOS (ai, s, c);
           $c(m=>0) = sinh (ar) * c;
           $c(m=>1) = cosh (ar) * s;
        ^
;

pp_def 'Ccosh',
	Pars => 'a(m=2); [o]c(m=2)',
	Inplace => 1,
        GenericTypes => [F,D],
        Doc => '  cosh (a) = (exp (a) + exp (-a)) / 2. Works inplace',
        Code => q^
           $GENERIC() ar = $a(m=>0), ai = $a(m=>1);
           double s, c;

           SINCOS (ai, s, c);
           $c(m=>0) = cosh (ar) * c;
           $c(m=>1) = sinh (ar) * s;
        ^
;

pp_def 'Ctanh',
	Pars => 'a(m=2); [o]c(m=2)',
	Inplace => 1,
        GenericTypes => [F,D],
        Doc => 'Works inplace',
        Code => q^
           $GENERIC() ar = $a(m=>0), ai = $a(m=>1);
           double den;
           double s, c;

           SINCOS (2*ai, s, c);
           den = cosh (2*ar) + c;

           $c(m=>0) = sinh (2*ar) / den;
           $c(m=>1) = s           / den;
        ^
;

pp_def 'Casinh',
	Pars => 'a(m=2); [o]c(m=2)',
	Inplace => 1,
        GenericTypes => [F,D],
        Doc => 'Works inplace',
        Code => q^
           $GENERIC() ar = $a(m=>0), ai = $a(m=>1);
           $GENERIC() yr = (ar-ai) * (ar+ai) + 1;
           $GENERIC() yi = 2*ar*ai;

           CSQRT ($GENERIC(), yr, yi, yr, yi)

           yr += ar;
           yi += ai;

           CLOG (yr, yi, $c(m=>0), $c(m=>1));
        ^
;

pp_def 'Cacosh',
	Pars => 'a(m=2); [o]c(m=2)',
	Inplace => 1,
        GenericTypes => [F,D],
        Doc => 'Works inplace',
        Code => q^
           $GENERIC() ar = $a(m=>0), ai = $a(m=>1);

           $GENERIC() yr = (ar-ai) * (ar+ai) - 1;
           $GENERIC() yi = 2*ar*ai;

           CSQRT ($GENERIC(), yr, yi, yr, yi)

           yr += ar;
           yi += ai;

           CLOG (yr, yi, $c(m=>0), $c(m=>1));
        ^
;

pp_def 'Catanh',
	Pars => 'a(m=2); [o]c(m=2)',
	Inplace => 1,
        GenericTypes => [F,D],
        Doc => 'Works inplace',
        Code => q^
           $GENERIC() ar = $a(m=>0), ai = $a(m=>1);

           double i2 = ai*ai;
           double num = i2 + (1+ar) * (1+ar);
           double den = i2 + (1-ar) * (1-ar);

           $c(m=>0) = 0.25 * (log(num) - log(den));
           $c(m=>1) = 0.5 * atan2 (2*ai, 1 - ar*ar - i2);
        ^
;

pp_def 'Cproj',
	Pars => 'a(m=2); [o]c(m=2)',
	Inplace => 1,
        GenericTypes => [F,D],
        Doc => 'compute the projection of a complex number to the riemann sphere. Works inplace',
        Code => q^
           $GENERIC() ar = $a(m=>0), ai = $a(m=>1);

           double den = ar*ar + ai*ai + 1;

           $c(m=>0) = 2*ar / den;
           $c(m=>1) = 2*ai / den;
        ^
;

pp_def 'Croots',
	Pars => 'a(m=2); [o]c(m=2,n)',
        OtherPars => 'int n => n',
        GenericTypes => [F,D],
        Doc => 'Compute the C<n> roots of C<a>. C<n> must be a positive integer. The result will always be a complex type!',
        PMCode => q^sub PDL::Complex::Croots($$) {
           my ($pdl, $n) = @_;
           my $r = PDL->null;
           &PDL::Complex::_Croots_int($pdl, $r, $n);
           bless $r;
        }^,
        Code => q^
           double s, c;
           double ar = $a(m=>0), ai = $a(m=>1),
                  n1 = 1 / (double)$COMP(n),
                  rr = pow (CABS (ar, ai), n1), /* do not optimize the sqrt out of this expr! */
                  at = atan2 (ai, ar) * n1,
                  ti = M_2PI * n1;

           loop(n) %{
               SINCOS (at, s, c);

               $c(m=>0) = rr * c;
               $c(m=>1) = rr * s;

               at += ti;
            %}
        ^
;

pp_def 'rCpolynomial',
       Pars => 'coeffs(n); x(c=2,m); [o]out(c=2,m)',
       Doc => 'evaluate the polynomial with (real) coefficients C<coeffs> at the (complex) position(s) C<x>. C<coeffs[0]> is the constant term.',
       GenericTypes => [F,D],
       Code => q!
          loop(m) %{
             double xr = 1;
             double xi = 0;
             double or = 0;
             double oi = 0;
             double Xr;

             loop(n) %{
                or += $coeffs() * xr;
                oi += $coeffs() * xi;

                Xr = xr;
                xr = Xr * $x(c=>0) - xi * $x(c=>1);
                xi = xi * $x(c=>0) + Xr * $x(c=>1);
             %}

             $out(c=>0) = or;
             $out(c=>1) = oi;
          %}
       !
;

pp_add_isa 'PDL';

pp_done;

