# This is PDL::Complex3, the complex number support for PDL version 3.
# PDL::Complex is deprecated in favor of this module. The main differences from
# the original are
#
# 1. This module only provides some functions for dealing with complex numbers;
#    it is NOT a class and has no methods. The old module was a class, and it
#    overrode some non-complex PDL functionality. Unfortunately it was highly
#    inconsistent in what was overridden and what wasn't, so it was difficult
#    for the user to know when they were using PDL::Complex functionality or
#    plain PDL functionality. The new modules is less ambitious, and this makes
#    is unambiguous to the user
#
# 2. As much as possible, no core math is implemented by us anymore. We now just
#    use the complex number support in C99

pp_addpm { At => 'Top' },    scalar `cat complex3.pod`;
pp_addhdr                    scalar `cat complex3.include.c`;
pp_addpm { At => 'Middle' }, scalar `cat complex3.include.pm`;

pp_add_exported('', $_) foreach (qw(re im Cstring Cprint));





# complex = f(complex)
my @c2c_ops  = ( { name => 'Cconj',  Doc  => 'Complex conjugate',    op   => 'rc = conj(ac)'},
                 { name => 'Cexp',   Doc  => 'Complex exponent',     op   => 'rc = exp(ac)'},
                 { name => 'Csin',   Doc  => 'Complex sin',          op   => 'rc = sin(ac)'},
                 { name => 'Ccos',   Doc  => 'Complex cos',          op   => 'rc = cos(ac)'},
                 { name => 'Ctan',   Doc  => 'Complex tan',          op   => 'rc = tan(ac)'},
                 { name => 'Casin',  Doc  => 'Complex arc-sin',      op   => 'rc = asin(ac)'},
                 { name => 'Cacos',  Doc  => 'Complex arc-cos',      op   => 'rc = acos(ac)'},
                 { name => 'Catan',  Doc  => 'Complex arc-tan',      op   => 'rc = atan(ac)'},
                 { name => 'Csinh',  Doc  => 'Complex sinh',         op   => 'rc = sinh(ac)'},
                 { name => 'Ccosh',  Doc  => 'Complex cosh',         op   => 'rc = cosh(ac)'},
                 { name => 'Ctanh',  Doc  => 'Complex tanh',         op   => 'rc = tanh(ac)'},
                 { name => 'Casinh', Doc  => 'Complex arc-sinh',     op   => 'rc = asinh(ac)'},
                 { name => 'Cacosh', Doc  => 'Complex arc-cosh',     op   => 'rc = acosh(ac)'},
                 { name => 'Catanh', Doc  => 'Complex arc-tanh',     op   => 'rc = atanh(ac)'},
                 { name => 'Clog',   Doc  => 'Complex natural log',  op   => 'rc = log(ac)'},
                 { name => 'Csqrt',  Doc  => 'Complex sqrt',         op   => 'rc = sqrt(ac)'} );

# real = f(complex)
my @c2r_ops = ( { name => 'Cabs', Doc  => 'complex C<abs()> (also known as I<modulus>)', op => '$c() = fabs(ac)'},
                { name => 'Carg', Doc  => 'complex argument function ("angle")',         op => '$c() = carg(ac)'} );

# complex = f(complex, complex)
my @cc2c_ops = ( { name => 'Cmul', Doc  => 'Complex multiplication',            op   => 'rc = ac * bc'},
                 { name => 'Cdiv', Doc  => 'Complex division',                  op   => 'rc = ac / bc'},
                 { name => 'Cpow', Doc  => 'Complex C<pow()> (C<**>-operator)', op   => 'rc = pow(ac, bc)'} );

for my $op( @c2r_ops )
{
  $op->{Pars} = 'a(m=2); [o]c()';
}
for my $op( @c2c_ops )
{
  $op->{Pars}               = 'a(m=2); [o]c(m=2)';
  $op->{has_complex_output} = 1;
}
for my $op( @cc2c_ops )
{
  $op->{Pars}               = 'a(m=2); b(m=2); [o]c(m=2)';
  $op->{has_arg2}           = 1;
  $op->{has_complex_output} = 1;
}
for my $op( @c2r_ops, @c2c_ops, @cc2c_ops )
{
  my $name = $op->{name};

  my $code = gen_complex_vars('ac', 'a');
  if( $op->{has_arg2} ) { $code .= gen_complex_vars('bc', 'b'); }

  $code .= gen_complex_vars( 'rc' )        if $op->{has_complex_output};
  $code .= $op->{op} . ";\n";
  $code .= gen_complex_output( 'c', 'rc' ) if $op->{has_complex_output};

  my %hash = ( Pars    => $op->{Pars},
               Doc     => $op->{Doc},
               Code    => $code );

  $hash{Inplace} = 1 if $op->{has_complex_output} && !$op->{has_arg2};

  pp_def( $name, %hash );
}










pp_def 'r2C',
       Pars => 'r(); [o]c(m=2)',
       Doc => 'convert real to complex, assuming an imaginary part of zero',
       Code => <<'EOF';
          $c(m=>0) = $r();
          $c(m=>1) = 0;
EOF

pp_def 'i2C',
       Pars => 'r(); [o]c(m=2)',
       Doc => 'convert imaginary to complex, assuming a real part of zero',
       Code => <<'EOF';
          $c(m=>0) = 0;
          $c(m=>1) = $r();
EOF

pp_def 'Cr2p',
       Pars => 'r(m=2); float+ [o]p(m=2)',
       Inplace => 1,
       Doc => 'convert complex numbers in rectangular form to polar (mod,arg) form. Works inplace',
       Code => gen_complex_vars('x', 'r') .
<<'EOF';
          $p(m=>0) = ($GENERIC()) fabs( x );
          $p(m=>1) = ($GENERIC()) carg( x );
EOF

pp_def 'Cp2r',
       Pars => 'r(m=2); [o]p(m=2)',
       Inplace => 1,
       Doc => 'convert complex numbers in polar (mod,arg) form to rectangular form. Works inplace',
       Code => gen_complex_vars('x', 'r') .
<<'EOF';
          double s, c;
          SINCOS (cimag(x), s, c);
          $p(m=>0) = c * creal(x);
          $p(m=>1) = s * creal(x);
EOF

pp_def 'Cprodover',
        Pars => 'a(m=2,n); [o]c(m=2)',
        Doc => 'Project via product to N-1 dimension; analogous to prodover()',
        Code => gen_complex_vars('p') . <<'EOF' .
           p = 1.0;

           loop(n) %{
             p *= $a(m=>0) + $a(m=>1)*I;
           %}
EOF
           gen_complex_output( 'c', 'p' );

pp_def 'Csumover',
        Pars => 'a(m=2,n); [o]c(m=2)',
        Doc => 'Project via sum to N-1 dimension; analogous to sumover()',
        Code => gen_complex_vars('s') . <<'EOF' .
           s = 0.0;

           loop(n) %{
             s += $a(m=>0) + $a(m=>1)*I;
           %}
EOF
           gen_complex_output( 'c', 's' );

pp_def 'Cscale',
	Pars => 'a(m=2); b(); [o]c(m=2)',
        Doc => 'mixed complex/real multiplication',
        Code => <<'EOF';
           $c(m=>0) = $a(m=>0) * $b();
           $c(m=>1) = $a(m=>1) * $b();
EOF


pp_def 'Cabs2',
	Pars => 'a(m=2); [o]c()',
        Doc => 'complex squared C<abs()> (also known I<squared modulus>)',
        Code => <<'EOF';
           $GENERIC() ar = $a(m=>0), ai = $a(m=>1);
           $c() = ar*ar + ai*ai;
EOF



pp_def 'Croots',
	Pars => 'a(m=2); float+ [o]c(m=2,n)',
        OtherPars => 'int n => n',
        GenericTypes => [F,D],
        Doc => 'Compute the C<n> roots of C<a>. C<n> must be a positive integer. The result is a piddle with C<n> complex values',
        Code => gen_complex_vars( 'ac', 'a' ) . <<'EOF';
           double s, c;
           double ar = $a(m=>0), ai = $a(m=>1),
                  n1 = 1.0 / (double)$COMP(n),
                  rr = pow ( fabs(ac), n1), /* do not optimize the sqrt out of this expr! */
                  at = atan2 (ai, ar) * n1,
                  ti = M_PI * 2.0 * n1;

           loop(n) %{
               SINCOS (at, s, c);

               $c(m=>0) = rr * c;
               $c(m=>1) = rr * s;

               at += ti;
            %}
EOF

pp_def 'rCpolynomial',
       Pars => 'coeffs(n); x(c=2,m); [o]out(c=2,m)',
       Doc => 'evaluate the polynomial with (real) coefficients C<coeffs> at the (complex) position(s) C<x>. C<coeffs[0]> is the constant term.',
       GenericTypes => [F,D],
       Code => gen_complex_vars('xc') .
               gen_complex_vars('oc') . <<'EOF';
          loop(m) %{
             xc = 1.0;
             oc = 0.0;

             loop(n) %{
                oc += $coeffs() * xc;
                xc *= $x(c=>0) + $x(c=>1) * I;
             %}

             $out(c=>0) = creal(oc);
             $out(c=>1) = cimag(oc);
          %}
EOF

pp_done;






sub gen_complex_vars
{
  my ($var_c, $var_perl) = @_;

  my $code = <<EOF;
  /* integers are upgraded to float */
  types(BSULQF) \%{  float complex $var_c; %}
  types(D)      \%{ double complex $var_c; %}
EOF

  if( defined $var_perl )
  {
    $code .= "$var_c = \$$var_perl(m=>0) + \$$var_perl(m=>1) * I;\n";
  }

  return $code;
}

sub gen_complex_output
{
  my ($var_perl, $var_c) = @_;

  return <<EOF;
    \$$var_perl(m=>0) = (\$GENERIC())creal( $var_c );
    \$$var_perl(m=>1) = (\$GENERIC())cimag( $var_c );
EOF
}
